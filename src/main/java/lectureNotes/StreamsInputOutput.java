package lectureNotes;

import java.io.ByteArrayInputStream;
import java.io.IOException;

import java.io.ByteArrayOutputStream;
import java.util.Arrays;

import java.io.CharArrayReader;

import java.io.CharArrayWriter;

import java.util.Scanner;

public class StreamsInputOutput {
}

/*
    Потоки ввода/вывода#
    Чтение и запись данных - это одна из фундаментальных задач в программировании. Если вдуматься, то любая программа
    - это чтение данных, преобразование их, и вывод куда-то. Мы можем читать данные с файла, с клавиатуры, с интернета,
    с дискеты, с жесткого диска, с оперативной памяти и еще с множества мест. Это же касается и вывода данных. Если
    делать отдельный класс для каждого из этих случаев (отдельный класс для работы с файлом, отдельный класс для работы
    с клавиатурой), то очень скоро мы столкнемся с проблемой множества специализированных классов. И код, который
    отлично работал с дискетами, не сможет читать данные с диска. Чтобы избежать этой проблемы, в Java чтение и запись
    данных построена вокруг понятия потоков ввода и вывода. Это интерфейсы, которые позволяют читать и записывать
    данные в определенном формате, не вдаваясь в подробности с чем именно мы работаем. Таким образом, мы можем написать
    программу, которая работает с файлами. А потом эта же программа, если она ориентирована на работу с потоками-ввода
    вывода, сможет и отлично работать с tcp-сокетами, потому что потоки ввода-вывода не привязаны к конкретной реализации.

    Потоки ввода-вывода в Java#
    В Java основной функционал работы с потоками сосредоточен в классах из пакета java.io. Ключевым понятием здесь
    является понятие потока. Понятие потока в программировании обозначает много вещей. В данном случае применительно к
    работе с файлами и вводом-выводом мы будем говорить о потоке (stream), как о абстракции, которая используется для
    чтения или записи информации (файлов, текста консоли и т.д.). Поток связан с реальным физическим устройством с
    помощью системы ввода-вывода Java. У нас может быть определен поток, который связан с файлом и через который мы
    можем вести чтение или запись файла. Все эти задачи: чтение и запись различных файлов, обмен информацией по сети,
    ввод-вывод в консоли мы будем решать в Java с помощью потоков. Объект, из которого можно считать данные, называется
    потоком ввода (input stream), а объект в который можно записывать данные - потоком вывода (output stream). Например,
    если надо считать содержание файла, то применяется поток ввода, а если надо записать в файл - то поток вывода.

    Иерархия потоков ввода-вывода#
    В основе всех классов, управляющих потоками байтов, находятся два абстрактных класса: InputStream (представляющий
    потоки ввода) и OutputStream (представляющий потоки вывода). Эти абстрактные классы работают на уровне отдельных
    байтов. Это универсальный способ (потому что любую информацию можно представить в виде набора байт), но не очень
    удобный. Чтобы сделать работу с потоками более удобной, есть абстрактные классы Reader (для чтения потоков символов),
    и Writer (для записи потока символов). Все остальные классы, работающие с потоками, являются наследниками этих
    абстрактных классов. Иерархия выглядит так:
    -------------------------------------------------------------------------------------------------------------------
    InputStream                    OutputStream                    Reader                    Writer
    FileInputStream                FileOutputStream                FileReader                FileWriter
    BufferedInputStream            BufferedOutputStream            BufferedReader            BufferedWriter
    ByteArrayInputStream           ByteArrayOutputStream           CharArrayReader           CharArrayWriter
    FilterInputStream              FilterOutputStream              FilterReader              FilterWriter
    DataInputStream                DataOutputStream
    ObjectInputStream              ObjectOutputStream
    -------------------------------------------------------------------------------------------------------------------
                                                Классы потоков в Java

    Класс InputStream#
    Класс InputStream является базовым для всех классов, управляющих байтовыми потоками ввода. Рассмотрим его основные
    методы: ### int available(): возвращает количество байтов, доступных для чтения в потоке; ### void close(): закрывает
    поток, освобождая захваченные ресурсы (например файлы); ### int read(): возвращает целочисленное представление
    следующего байта в потоке. Когда в потоке не останется доступных для чтения байтов, данный метод возвратит число -1;
    ### int read(byte[] buffer): считывает байты из потока в массив buffer. Возвращает количество записанных в буфер
    байт. Если ничего не было прочитано, возвращается число -1; ### int read(byte[] buffer, int offset, int length):
    считывает некоторое количество байтов, меньше или равное length, из потока в массив buffer. При этом считанные
    байты помещаются в массив, начиная со смещения offset, то есть с элемента buffer[offset]. Метод возвращает число
    успешно прочитанных байт. Это число может быть меньше length, если в потоке недостаточно символов;
    ### long skip(long number): пропускает в потоке number байт. Таким образом, общая работа с потоком вида InputStream
    выглядит следующим образом: 1) Открыли поток. 2) Прочитали нужное количество данных, используя методы available()
    и read(). 3) Закрыли поток

    ByteArrayInputStream#
    Как пример рассмотрим поток ByteArrayInputStream. Этот поток читает информацию из массива байт.
*/
class ByteArrayInputStreamTest { // класс
    public static void main(String[] args) throws IOException { // запускалка с имплементацией исключения
        byte[] bytes = {1, 3, 5, 7, 9}; // массив из байта элементов
        ByteArrayInputStream bais = new ByteArrayInputStream(bytes); // переменная типа БайтМассивВводПоток

        while (bais.available() > 0) { // выполнять, пока есть байты, для чтения в потоке
            byte currentByte = (byte) bais.read(); //переменная типа байт со значением = следующего байта в потоке, насильно приведенным в тип байт
            System.out.println(currentByte); // вывести в консоль значение переменной currentByte
        }

        bais.close(); //закрыть поток
    }
}
/*
Код выше выведет в консоль по очереди 1, 3, 5, 7, 9. В цикле while мы каждый раз проверяем есть ли хоть один байт для
чтения (bais.available() > 0). Дальше считывается один байт (вызовом bais.read()), и выводится в консоль. В конце поток
закрывается вызовом метода close(). Читать данные по одному байту неэффективно, поэтому обычно данные читаются блоками
(типично по 1024 байта или кратно, потому что это размер килобайта). Вот код, который работает точно так же, но
считывает все данные сразу одним вызовом read():
*/
class ByteArrayInputStreamTest1 { // класс
    public static void main(String[] args) throws IOException { // запускалка с имплементацией исключения
        byte[] bytes = {1, 3, 5, 7, 9}; // массив из байта элементов
        ByteArrayInputStream bais = new ByteArrayInputStream(bytes); // переменная типа БайтМассивВводПоток

        byte[] buffer = new byte[1024]; // пустой массив из 1024 пустых байта элементов
        int readByteCount = bais.read(buffer, 0, buffer.length); // переменная инт в которую сохранено, результат работы метода.
        // из массива buffer, и позиции 0 в этом массиве, до меньше или равное buffer.length

        for(int i = 0; i < readByteCount; i++) { // пробежка по переменной в которую записали считанные данные
            System.out.println(buffer[i]); // вывести в консоль значение позиции из полученного считанного массива
        }

        bais.close(); // закрыть поток
    }
}
/*
Здесь мы объявили переменную buffer, размером в 1024 байта. Дальше прочитали данные в этот буфер. В переменную readyByteCount
мы сохранили количество прочитанных байт. Дальше в цикле вывели readyByteCount байт из массива buffer.

    Класс OutputStream#
    Класс OutputStream является базовым классом для всех классов, которые работают с байтовыми потоками на запись.
    Основные методы: ### void close(): закрывает поток; ### void flush(): очищает буфер вывода, записывая все его содержимое;
    ### void write(int b): записывает в выходной поток один байт b; ### void write(byte[] buffer): записывает в выходной
    поток массив байтов buffer; ### void write(byte[] buffer, int offset, int length): записывает в выходной поток
    length байт из массива buffer, начиная со смещения offset, то есть с элемента buffer[offset]. Таким образом, общая
    работа с потоком вида OutputStream выглядит следующим образом: 1) Открыли поток. 2) Записали нужное количество данных,
    используя методы write. 3) Закрыли поток, вызвав метод flush(). 4) Закрыли поток.

    ByteArrayOutputStream#
    Для примера рассмотрим одну из реализаций OutputStream - ByteArrayOutputStream. Этот поток позволяет накапливать
    информацию в массиве байт:
*/

class ByteArrayOutputStreamTest { // класс
    public static void main(String[] args) throws IOException { // запускалка с имплементацией исключения
        ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);  // переменная типа БайтМассивВыводПоток со значением 1024

        for(int i = 1; i < 10; i++) { // пробежка от 1 до 9
            baos.write(i); // запись в переменную, одного байта
        }

        baos.flush(); // очищает буфер вывода, записывая все его содержимое

        System.out.println(Arrays.toString(baos.toByteArray())); // вывести в консоль всю переменную

        baos.close(); // закрыть поток
    }
}
/*
Код выше выведет в консоль [1, 2, 3, 4, 5, 6, 7, 8, 9]. В этом примере мы вначале создаем поток байтового ввода.
Дальше в цикле мы записываем цифры от 1 до 9 включительно в поток baos. В конце получаем результирующий массив вызовом
метода baos.toByteArray(), и выводим его в консоль. В конце работы программы закрываем поток вызовом baos.close().

    Класс Reader#
    Абстрактный класс Reader предоставляет функционал для чтения символов (char). Основные методы этого класса:
    ### absract void close(): закрывает поток ввода; ### int read(): возвращает целочисленное представление следующего
    символа в потоке. Если таких символов нет, и достигнут конец файла, то возвращается число -1; ### int read(char[] buffer):
    считывает в массив buffer из потока до buffer.length символов включительно. Возвращает количество успешно считанных
    символов. При достижении конца данных, которые можно прочитать, возвращает -1; ### int read(CharBuffer buffer):
    считывает в объект CharBuffer символы. Возвращает количество успешно считанных символов. При достижении конца данных,
    которые можно прочитать, возвращает -1; ### absract int read(char[] buffer, int offset, int count): считывает в
    массив buffer, начиная со смещения offset, из потока, символы, количество которых равно count; ### long skip(long count):
    пропускает количество count символов. Возвращает число успешно пропущенных символов.

    CharArrayReader#
    В качестве примера рассмотрим реализацию CharReader - CharArrayReader. Это класс, который позволяет читать данные
    с потока символов:
*/
class CharArrayReaderTest { // класс
    public static void main(String[] args) throws IOException { // запускалка с имплементацией исключения
        char[] chars = {'J', 'a', 'v', 'a'}; // переменная типа массива чар, с буквами из слова Java

        CharArrayReader reader = new CharArrayReader(chars); // переменная типа ЧарМассивЧитать с сохраненным массивом в нее

        int nextChar = -1; // что типа переменной на случай аварийных не стыковок, объявленной с минус единицей
        while((nextChar = reader.read()) != -1) { //выполнять пока значение следующего символа не равно -1
            char c = (char) nextChar; // насильно превратить число в чар
            System.out.println(c); // вывести в консоль это значение
        }
    }
}
/*
Код выше выводит в консоль текст:
J
a
v
a

Мы объявляем переменную nextChar. Она типа int, потому что метод read() возвращает -1 если данных больше нет. Чтение
данных по одному символу не очень эффективно. Поэтому лучше читать данные пакетами:
*/
class CharArrayReaderTest1 { // класс
    public static void main(String[] args) throws IOException { // запускалка с имплементацией исключения
        char[] chars = {'J', 'a', 'v', 'a'}; // переменная типа массива чар, с буквами из слова Java

        CharArrayReader reader = new CharArrayReader(chars);  // переменная типа ЧарМассивЧитать с сохраненным массивом в нее

        char[] buffer = new char[1024]; // новый массив с кучей пустых элементов

        int charCount = reader.read(buffer, 0, buffer.length); // переменная инт в которую сохранено, результат работы метода.
        // из массива buffer, и позиции 0 в этом массиве, до меньше или равное buffer.length

        for(int i = 0; i < charCount; i++) { //пробежка по переменной charCount
            System.out.println(buffer[i]); // вывести в консоль элемент на данном шаге из переменной charCount
        }
    }
}
/*
Код выше работает аналогично предыдущему, но считывает до 1024 символов за один раз. Это намного эффективней,
чем читать символы по одному.

    Класс Writer#
    Класс Writer определяет функционал для всех символьных потоков вывода. Его основные методы: ### Writer append(char c):
    добавляет в конец выходного потока символ c. Возвращает объект Writer; ### Writer append(CharSequence chars):
    добавляет в конец выходного потока набор символов chars. Возвращает объект Writer; ### abstract void close():
    закрывает поток; ### abstract void flush(): очищает буферы потока; ### void write(int c): записывает в поток один
    символ, который имеет целочисленное представление; ### void write(char[] buffer): записывает в поток массив символов
    buffer; ### absract void write(char[] buffer, int off, int len): записывает в поток len символов из массива buffer,
    начиная с индекса off; ### void write(String str): записывает в поток строку str;
    ### void write(String str, int off, int len): записывает в поток из строки str len символов, начиная с индекса off;

    CharArrayWriter#
    Как пример рассмотрим класс CharArrayWriter, который унаследуется от класса Writer. Он позволяет накапливать входные
    данные и потом получить их в виде массива char[]:
*/
class CharArrayWriterTest { //класс
    public static void main(String[] args) throws IOException { // запускалка с имплементацией исключения
        CharArrayWriter charArrayWriter = new CharArrayWriter(); // экземпляр класс ЧарМассивЗапись - поток

        charArrayWriter.append("Java"); // добавляем в этот экземпляр слово

        char[] result = charArrayWriter.toCharArray(); // в новый массив запихиваем тот экземпляр трансформировав в чар

        System.out.println(Arrays.toString(result)); // вывести тот массив в консоль
    }
}
/*
В коде выше мы объявили поток charArrayWriter. Дальше методом append() добавили туда строку Java. Получили результат в
виде массива символов, и заносим в переменную result. И выводим этот массив, получая в консоли текст [J, a, v, a].

    System.in#
    Чтобы получать данные с клавиатуры, есть специальный поток System.in. Это статическое поле класса System. С этим
    потоком можно работать так же, как и с любым другим потоком - считывать байты по одному и группами. Делать это не
    особо удобно, поэтому обычно этот поток оборачивают в какой-то другой класс - например Scanner.

    Класс Scanner#
    Класс Scanner - это удобный способ читать данные в типизированном виде с любого входного потока. В простейшем
    варианте мы даем в конструктор этого класса входной поток, с которого считываем данные, и дальше вызываем методы
    для чтения необходимых данных:
*/
    //Scanner scanner = new Scanner(System.in); // создает экземпляр класса сканер, работающий с потоком данных с клавиатуры
    //String line = scanner.nextLine(); // в переменную будет присвоено введенное значение с клавиатуры в консоль
/*
    У класса Scanner есть группа методов, начинающихся со слова next, каждый из которых читает блок информации
    определенного типа. Вот несколько примеров: ### nextInt() - прочитать число типа int; ### nextLine() - прочитать
    строку String до переноса строки (пока пользователь не нажал Enter); Чтобы узнать, есть ли во входном потоке еще
    данные, есть похожая группа методов, начинающаяся со слова ### hasNext. Например, вот так можно прочитать все
    строки с консоли:
*/
class ScannerTest { // класс
    public static void main(String[] args) { // запускалка
        String numbers = "10 20 30"; // строка с числами
        Scanner scanner = new Scanner(numbers); // экземпляр класса сканер, для работы с числами
        while (scanner.hasNextInt()) { // выполнять код внутри пока, есть следующее число
            System.out.print(scanner.nextInt() + " "); // вывести в консоль число, и добавить пробел после него
        }
    }
}
/*
Scanner также может считывать данные из строки, как в примере выше. В этой программе мы считываем числа, пока не
закончится строка. В консоль выведется строка 10 20 30 .
 */