package lectureNotes;

public class StreamsInputOutput {
}

/*
    Потоки ввода/вывода
Чтение и запись данных - это одна из фундаментальных задач в программировании. Если вдуматься, то любая программа - это чтение данных, преобразование их, и вывод куда-то.

Мы можем читать данные с файла, с клавиатуры, с интернета, с дискеты, с жесткого диска, с оперативной памяти и еще с множества мест. Это же касается и вывода данных.

Если делать отдельный класс для каждого из этих случаев (отдельный класс для работы с файлом, отдельный класс для работы с клавиатурой), то очень скоро мы столкнемся с проблемой множества специализированных классов. И код, который отлично работал с дискетами, не сможет читать данные с диска.

Чтобы избежать этой проблемы, в Java чтение и запись данных построена вокруг понятия потоков ввода и вывода. Это интерфейсы, которые позволяют читать и записывать данные в определенном формате, не вдаваясь в подробности с чем именно мы работаем.

Таким образом, мы можем написать программу, которая работает с файлами. А потом эта же программа, если она ориентирована на работу с потоками-ввода вывода, сможет и отлично работать с tcp-сокетами, потому что потоки ввода-вывода не привязаны к конкретной реализации.

Потоки ввода-вывода в Java#
В Java основной функционал работы с потоками сосредоточен в классах из пакета java.io.

Ключевым понятием здесь является понятие потока. Понятие потока в программировании обозначает много вещей. В данном случае применительно к работе с файлами и вводом-выводом мы будем говорить о потоке (stream), как о абстракции, которая используется для чтения или записи информации (файлов, текста консоли и т.д.).

Поток связан с реальным физическим устройством с помощью системы ввода-вывода Java. У нас может быть определен поток, который связан с файлом и через который мы можем вести чтение или запись файла. Все эти задачи: чтение и запись различных файлов, обмен информацией по сети, ввод-ввывод в консоли мы будем решать в Java с помощью потоков.

Объект, из которого можно считать данные, называется потоком ввода (input stream), а объект, в который можно записывать данные, - потоком вывода (output stream). Например, если надо считать содержание файла, то применяется поток ввода, а если надо записать в файл - то поток вывода.

Иерархия потоков ввода-вывода#
В основе всех классов, управляющих потоками байтов, находятся два абстрактных класса: InputStream (представляющий потоки ввода) и OutputStream (представляющий потоки вывода).

Эти абстрактные классы работают на уровне отдельных байтов. Это универсальный способ (потому что любую информацию можно представить в виде набора байт), но не очень удобный.

Чтобы сделать работу с потоками более удобной, есть абстрактные классы Reader (для чтения потоков символов), и Writer (для записи потока символов).

Все остальные классы, работающие с потоками, являются наследниками этих абстрактных классов. Иерархия выглядит так:


Классы потоков в Java
Класс InputStream#
Класс InputStream является базовым для всех классов, управляющих байтовыми потоками ввода. Рассмотрим его основные методы:

int available(): возвращает количество байтов, доступных для чтения в потоке;

void close(): закрывает поток, освобождая захваченные ресурсы (например файлы);

int read(): возвращает целочисленное представление следующего байта в потоке. Когда в потоке не останется доступных для чтения байтов, данный метод возвратит число -1;

int read(byte[] buffer): считывает байты из потока в массив buffer. Возвращает количество записанных в буфер байт. Если ничего не было прочитано, возвращается число -1;

int read(byte[] buffer, int offset, int length): считывает некоторое количество байтов, меньше или равное length, из потока в массив buffer. При этом считанные байты помещаются в массив, начиная со смещения offset, то есть с элемента buffer[offset]. Метод возвращает число успешно прочитанных байт. Это число может быть меньше length, если в потоке недостаточно символов;

long skip(long number): пропускает в потоке number байт.

Таким образом, общая работа с потоком вида InputStream выглядит следующим образом:

Открыли поток.
Прочитали нужное количество данных, используя методы available() и read().
Закрыли поток
ByteArrayInputStream#
Как пример рассмотрим поток ByteArrayInputStream. Этот поток читает информацию из массива байт.

import java.io.ByteArrayInputStream;
import java.io.IOException;

public class ByteArrayInputStreamTest {
    public static void main(String[] args) throws IOException {
        byte[] bytes = {1, 3, 5, 7, 9};
        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);

        while (bais.available() > 0) {
            byte currentByte = (byte) bais.read();
            System.out.println(currentByte);
        }

        bais.close();
    }
}
Код выше выведет в консоль по очереди 1, 3, 5, 7, 9. В цикле while мы каждый раз проверяем есть ли хоть один байт для чтения (bais.available() > 0). Дальше считывается один байт (вызовом bais.read()), и выводится в консоль. В конце поток закрывается вызовом метода close().

Читать данные по одному байту неэффективно, поэтому обычно данные читаются блоками (типично по 1024 байта или кратно, потому что это размер килобайта).

Вот код, который работает точно так же, но считывает все данные сразу одним вызовом read():

import java.io.ByteArrayInputStream;
import java.io.IOException;

public class ByteArrayInputStreamTest {
    public static void main(String[] args) throws IOException {
        byte[] bytes = {1, 3, 5, 7, 9};
        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);

        byte[] buffer = new byte[1024];
        int readByteCount = bais.read(buffer, 0, buffer.length);

        for(int i = 0; i < readByteCount; i++) {
            System.out.println(buffer[i]);
        }

        bais.close();
    }
}
Здесь мы объявили переменную buffer, размером в 1024 байта. Дальше прочитали данные в этот буфер. В переменную readyByteCount мы сохранили количество прочитанных байт. Дальше в цикле вывели readyByteCount байт из массива buffer.

Класс OutputStream#
Класс OutputStream является базовым классом для всех классов, которые работают с байтовыми потоками на запись.

Основные методы

void close(): закрывает поток;

void flush(): очищает буфер вывода, записывая все его содержимое;

void write(int b): записывает в выходной поток один байт b;

void write(byte[] buffer): записывает в выходной поток массив байтов buffer;

void write(byte[] buffer, int offset, int length): записывает в выходной поток length байт из массива buffer, начиная со смещения offset, то есть с элемента buffer[offset].

Таким образом, общая работа с потоком вида OutputStream выглядит следующим образом:

Открыли поток.
Записали нужное количество данных, используя методы write.
Закрыли поток, вызвав метод flush()
Закрыли поток
ByteArrayOutputStream#
Для примера рассмотрим одну из реализаций OutputStream - ByteArrayOutputStream. Этот поток позволяет накапливать информацию в массиве байт:

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Arrays;

public class ByteArrayOutputStreamTest {
    public static void main(String[] args) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);

        for(int i = 1; i < 10; i++) {
            baos.write(i);
        }

        baos.flush();

        System.out.println(Arrays.toString(baos.toByteArray()));

        baos.close();
    }
}
Код выше выведет в консоль [1, 2, 3, 4, 5, 6, 7, 8, 9].

В этом примере мы вначале создаем поток байтового ввода. Дальше в цикле мы записываем цифры от 1 до 9 включительно в поток baos. В конце получаем результирующий массив вызовом метода baos.toByteArray(), и выводим его в консоль. В конце работы программы закрываем поток вызовом baos.close().

Класс Reader#
Абстрактный класс Reader предоставляет функционал для чтения символов (char).

Основные методы этого класса:

absract void close(): закрывает поток ввода;

int read(): возвращает целочисленное представление следующего символа в потоке. Если таких символов нет, и достигнут конец файла, то возвращается число -1;

int read(char[] buffer): считывает в массив buffer из потока до buffer.length символов включительно. Возвращает количество успешно считанных символов. При достижении конца данных, которые можно прочитать, возвращает -1;

int read(CharBuffer buffer): считывает в объект CharBuffer символы. Возвращает количество успешно считанных символов. При достижении конца данных, которые можно прочитать, возвращает -1;

absract int read(char[] buffer, int offset, int count): считывает в массив buffer, начиная со смещения offset, из потока символы, количество которых равно count;

long skip(long count): пропускает количество count символов. Возвращает число успешно пропущенных символов.

CharArrayReader#
В качестве примера рассмотрим реализацию CharReader - CharArrayReader. Это класс, который позволяет читать данные с потока символов:

import java.io.CharArrayReader;
import java.io.IOException;

public class CharArrayReaderTest {
    public static void main(String[] args) throws IOException {
        char[] chars = {'J', 'a', 'v', 'a'};

        CharArrayReader reader = new CharArrayReader(chars);

        int nextChar = -1;
        while((nextChar = reader.read()) != -1) {
            char c = (char) nextChar;
            System.out.println(c);
        }
    }
}
Код выше выводит в консоль текст:

J
a
v
a
Мы объявляем переменную nextChar. Она типа int, потому что метод read() возвращает -1 если данных больше нет.

Чтение данных по одному символу не очень эффективно. Поэтому лучше читать данные пакетами:

import java.io.CharArrayReader;
import java.io.IOException;

public class CharArrayReaderTest {
    public static void main(String[] args) throws IOException {
        char[] chars = {'J', 'a', 'v', 'a'};

        CharArrayReader reader = new CharArrayReader(chars);

        char[] buffer = new char[1024];

        int charCount = reader.read(buffer, 0, buffer.length);

        for(int i = 0; i < charCount; i++) {
            System.out.println(buffer[i]);
        }
    }
}
Код выше работает аналогично предыдущему, но считывает до 1024 символов за один раз. Это намного эффективней, чем читать символы по одному.

Класс Writer#
Класс Writer определяет функционал для всех символьных потоков вывода. Его основные методы:

Writer append(char c): добавляет в конец выходного потока символ c. Возвращает объект Writer;

Writer append(CharSequence chars): добавляет в конец выходного потока набор символов chars. Возвращает объект Writer;

abstract void close(): закрывает поток;

abstract void flush(): очищает буферы потока;

void write(int c): записывает в поток один символ, который имеет целочисленное представление;

void write(char[] buffer): записывает в поток массив символов buffer;

absract void write(char[] buffer, int off, int len): записывает в поток len символов из массива buffer, начиная с индекса off;

void write(String str): записывает в поток строку str;

void write(String str, int off, int len): записывает в поток из строки str len символов, начиная с индекса off;

CharArrayWriter#
Как пример рассмотрим класс CharArrayWriter, который унаследуется от класса Writer. Он позволяет накапливать входные данные и потом получить их в виде массива char[]:

import java.io.CharArrayWriter;
import java.io.IOException;
import java.util.Arrays;

public class CharArrayWriterTest {
    public static void main(String[] args) throws IOException {
        CharArrayWriter charArrayWriter = new CharArrayWriter();

        charArrayWriter.append("Java");

        char[] result = charArrayWriter.toCharArray();

        System.out.println(Arrays.toString(result));
    }
}
В коде выше мы объявили поток charArrayWriter. Дальше методом append() добавили туда строку Java. Получили результат в виде массива символов, и заносим в переменную result. И выводим этот массив, получая в консоли текст [J, a, v, a].

System.in#
Чтобы получать данные с клавиатуры, есть специальный поток System.in. Это статическое поле класса System. С этим потоком можно работать так же, как и с любым другим потоком - считывать байты по одному и группами.

Делать это не особо удобно, поэтому обычно этот поток оборачивают в какой-то другой класс - например Scanner.

Класс Scanner#
Класс Scanner - это удобный способ читать данные в типизированном виде с любого входного потока.

В простейшем варианте мы даем в конструктор этого класса входной поток, с которого считываем данные, и дальше вызываем методы для чтения необходимых данных:

Scanner scanner = new Scanner(System.in);
String line = scanner.nextLine();
У класса Scanner есть группа методов, начинающихся со слова next, каждый из которых читает блок информации определенного типа. Вот несколько примеров:

nextInt() - прочитать число типа int;
nextLine() - прочитать строку String до переноса строки (пока пользователь не нажал Enter);
Чтобы узнать, есть ли во входном потоке еще данные, есть похожая группа методов, начинающаяся со слова hasNext. Например, вот так можно прочитать все строки с консоли:

import java.util.Scanner;

public class ScannerTest {
    public static void main(String[] args) {
        String numbers = "10 20 30";
        Scanner scanner = new Scanner(numbers);
        while (scanner.hasNextInt()) {
            System.out.print(scanner.nextInt() + " ");
        }
    }
}
Scanner также может считывать данные из строки, как в примере выше. В этой программе мы считываем числа, пока не закончится строка. В консоль выведется строка 10 20 30 .
 */